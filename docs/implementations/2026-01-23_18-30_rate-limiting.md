# Rate Limiting (DoS & Abuse Prevention)

> **Implementado em:** 2026-01-23
> **Status:** ✅ 95% Production-ready

---

## Descrição

Sistema completo de rate limiting usando slowapi para prevenir abuso e ataques DoS. Cada endpoint tem um limite de requisições por minuto baseado no IP do cliente.

---

## Arquivos Modificados/Criados

- **Middleware Global:** `main.py` - slowapi middleware + exception handler
- **Configurações:** `src/config.py` - Rate limits por categoria
- **Routes Protegidos:** 25 endpoints com decorators @limiter.limit()
  - `src/api/ingest_routes.py` - 1 endpoint
  - `src/api/routes.py` - 7 endpoints
  - `src/api/human_routes.py` - 2 endpoints
  - `src/api/telegram_routes.py` - 5 endpoints
  - `src/api/company_routes.py` - 5 endpoints
  - `src/api/api_key_routes.py` - 3 endpoints

---

## Como Funciona

### Processo:
1. Cliente faz requisição
2. slowapi verifica quantas requisições esse IP fez no último minuto
3. Se dentro do limite: processa normalmente
4. Se exceder limite: retorna **429 Too Many Requests**

### Headers de Resposta:
```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 87
X-RateLimit-Reset: 1674567890
```

---

## Configuração

### Middleware Global (main.py)
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from slowapi.middleware import SlowAPIMiddleware

# Initialize rate limiter
limiter = Limiter(key_func=get_remote_address, default_limits=["100/minute"])

# Add to app
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
app.add_middleware(SlowAPIMiddleware)
```

### Configurações (src/config.py)
```python
# Rate Limiting Configuration (API protection)
rate_limit_default: str = "100/minute"  # Default rate limit
rate_limit_ingest: str = "20/minute"    # Message ingestion
rate_limit_pipeline: str = "10/minute"  # Pipeline execution
rate_limit_read: str = "200/minute"     # Read operations
rate_limit_write: str = "30/minute"     # Write operations
rate_limit_admin: str = "10/minute"     # Admin operations
```

---

## Limites por Tipo de Operação

### Categoria 1: Ingestion (20/min)
- `POST /api/ingest-message` - Previne spam de mensagens
- Protege contra flood de tickets

### Categoria 2: Heavy Operations (10/min)
- `POST /api/run_pipeline/{ticket_id}` - Pipeline é caro (OpenAI calls)
- Previne abuso de processamento de IA

### Categoria 3: Read Operations (200/min)
- `GET /api/tickets/{ticket_id}`
- `GET /api/tickets/{ticket_id}/audit`
- `GET /api/tickets/{ticket_id}/interactions`
- `GET /api/tickets/{ticket_id}/agent_states`
- `GET /api/tickets` (list)
- `GET /api/companies/{company_id}`
- `GET /api/companies/` (list)
- `GET /api/human/escalated`
- Operações de leitura podem ter limite mais alto

### Categoria 4: Write Operations (30/min)
- `POST /api/tickets` - Criar ticket
- `POST /api/human/reply` - Responder ticket
- `PUT /api/companies/{company_id}` - Atualizar config
- Operações de escrita moderadamente limitadas

### Categoria 5: Admin Operations (10/min)
- `POST /api/companies/` - Criar company config
- `POST /api/keys/` - Criar API key
- `DELETE /api/keys/{key_id}` - Revogar API key
- `GET /api/keys/` - Listar API keys
- Operações administrativas mais restritas

### Categoria 6: Critical Admin (5/min)
- `DELETE /api/companies/{company_id}` - Deletar company
- `POST /telegram/webhook/set` - Configurar webhook
- `POST /telegram/webhook/delete` - Deletar webhook
- Operações críticas extremamente limitadas

### Categoria 7: Public Endpoints (50/min)
- `POST /telegram/webhook` - Webhook público (Telegram servers)
- Menos restritivo (Telegram faz poucas chamadas)

---

## Endpoints Protegidos (25)

### Exemplo de Aplicação:
```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from fastapi import Request

# Initialize limiter
limiter = Limiter(key_func=get_remote_address)

# Apply to endpoint
@router.post("/ingest-message")
@limiter.limit("20/minute")  # Rate limit decorator
async def ingest_message(
    http_request: Request,  # Required by slowapi
    request: IngestMessageRequest,
    api_key: dict = Depends(verify_api_key)
):
    # ... endpoint logic
```

---

## Response ao Exceder Limite

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 42
X-RateLimit-Limit: 20
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1674567890

{
  "error": "Rate limit exceeded: 20 per 1 minute"
}
```

---

## Testes de Rate Limiting

### Teste Manual com curl
```bash
for i in {1..25}; do
  curl -X POST http://localhost:8000/api/ingest-message \
    -H "X-API-Key: sk_..." \
    -H "Content-Type: application/json" \
    -d '{"channel":"telegram","text":"test","external_user_id":"test123"}' \
    -w "\nStatus: %{http_code}\n"
  sleep 1
done

# Primeiros 20: 200 OK
# Próximos 5: 429 Too Many Requests
```

---

## Boas Práticas

### DO:
- ✅ Usar limites apropriados para cada tipo de endpoint
- ✅ Documentar limites no README e API docs
- ✅ Incluir headers `X-RateLimit-*` nas respostas
- ✅ Configurar `Retry-After` header em 429

### DON'T:
- ❌ Usar mesmo limite para todas as operações
- ❌ Limites muito baixos (frustra usuários legítimos)
- ❌ Limites muito altos (não protege contra abuso)
- ❌ Esquecer de adicionar `Request` param (slowapi precisa)

---

## Exemplos de Código

### Rate Limit por Categoria
```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from fastapi import Request

limiter = Limiter(key_func=get_remote_address)

@router.post("/api/ingest-message")
@limiter.limit("20/minute")  # Ingestion: spam prevention
async def ingest_message(http_request: Request, request: IngestMessageRequest):
    pass

@router.get("/api/tickets")
@limiter.limit("200/minute")  # Read: higher limit
async def list_tickets(http_request: Request):
    pass

@router.post("/api/run_pipeline/{ticket_id}")
@limiter.limit("10/minute")  # Heavy: expensive operations
async def run_pipeline(http_request: Request, ticket_id: str):
    pass
```

### Custom Exception Handler
```python
from slowapi.errors import RateLimitExceeded
from fastapi import Request, status
from fastapi.responses import JSONResponse

async def rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):
    """Custom handler for 429 responses"""
    return JSONResponse(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        content={
            "error": f"Rate limit exceeded: {exc.detail}",
            "retry_after": exc.retry_after
        },
        headers={
            "Retry-After": str(exc.retry_after),
            "X-RateLimit-Limit": str(exc.limit),
            "X-RateLimit-Remaining": "0"
        }
    )

# Register handler
app.add_exception_handler(RateLimitExceeded, rate_limit_exceeded_handler)
```

---

## Testes Realizados

- ✅ Rate limit por IP
- ✅ Limites diferentes por categoria
- ✅ Response 429 com headers corretos
- ✅ Retry-After header
- ✅ X-RateLimit-* headers
- ✅ Reset após 1 minuto
- ✅ Preflight cache (10min)

---

## Troubleshooting

### Limite muito baixo
```bash
# Ajuste em src/config.py
rate_limit_ingest: str = "50/minute"  # Aumentar conforme necessário
```

### Limite muito alto
```bash
# Reduza em src/config.py
rate_limit_ingest: str = "10/minute"  # Reduzir conforme necessário
```

### Headers não aparecem
```bash
# Verifique se o exception handler está registrado
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
```

---

## Referências

- [ARCHITECTURE.md](../../ARCHITECTURE.md) - Visão geral do projeto
- [AI_INSTRUCTIONS.md](../../AI_INSTRUCTIONS.md) - Guia para agentes de IA
- [Input Sanitization](2026-01-23_18-30_input-sanitization.md) - Prevenção de XSS/Injection
- [CORS Hardening](2026-01-23_18-30_cors-hardening.md) - Segurança de origem
